<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>DodecaPatch vSim-PRO v3 ULTRA</title>
<style>
  :root{
    --bg0:#05070b;
    --bg1:#050a12;
    --panel:#0b1220cc;
    --panel2:#0b1324e6;
    --stroke:#1a2a44;
    --grid:#0b1a2e;
    --text:#d7e7ff;
    --muted:#8fb1d9;
    --accent:#3ad7ff;      /* NASA cyan */
    --accent2:#4bff8a;     /* neon green */
    --warn:#ffcf5b;
    --bad:#ff4b5c;
    --good:#33ff99;
    --shadow: 0 22px 55px rgba(0,0,0,.55);
    --radius:18px;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    color:var(--text);
    font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background:
      radial-gradient(1200px 700px at 20% -10%, rgba(58,215,255,.12), transparent 60%),
      radial-gradient(900px 600px at 85% 10%, rgba(75,255,138,.09), transparent 55%),
      radial-gradient(1200px 900px at 50% 110%, rgba(58,215,255,.06), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg0));
    overflow-x:hidden;
  }

  /* subtle NASA grid */
  body:before{
    content:"";
    position:fixed; inset:0;
    background:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 48px 48px;
    opacity:.22;
    pointer-events:none;
    mask-image: radial-gradient(circle at 50% 10%, rgba(0,0,0,.95), rgba(0,0,0,.2) 60%, rgba(0,0,0,.0) 82%);
  }

  .wrap{
    max-width: 1100px;
    margin: 18px auto 48px;
    padding: 0 14px 32px;
  }

  header{
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:12px;
    padding: 12px 6px 8px;
    border-bottom:1px solid rgba(58,215,255,.18);
  }

  .brand{
    display:flex; gap:10px; align-items:center;
  }
  .brand .logo{
    width:34px;height:34px;border-radius:10px;
    background: linear-gradient(135deg, rgba(58,215,255,.25), rgba(75,255,138,.18));
    border:1px solid rgba(58,215,255,.25);
    box-shadow: 0 0 25px rgba(58,215,255,.12);
    display:grid;place-items:center;
    font-weight:800;
    letter-spacing:.5px;
  }
  .brand h1{
    margin:0;
    font-size:18px;
    letter-spacing:.8px;
  }
  .brand h1 span{
    color:var(--accent);
    font-weight:800;
  }
  .sub{
    margin:2px 0 0;
    color:var(--muted);
    font-size:12px;
    letter-spacing:.2px;
  }

  .meta{
    text-align:right;
    color:var(--muted);
    font-size:12px;
    display:flex;
    flex-direction:column;
    gap:2px;
    min-width: 260px;
  }
  .meta b{color:var(--text); font-weight:650}
  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding: 6px 10px;
    border-radius: 999px;
    border:1px solid rgba(58,215,255,.20);
    background: rgba(8,14,24,.55);
    box-shadow: 0 10px 30px rgba(0,0,0,.3);
    width:fit-content;
    margin-left:auto;
  }
  .dot{
    width:10px;height:10px;border-radius:999px;
    background: var(--accent2);
    box-shadow: 0 0 18px rgba(75,255,138,.5);
  }

  .grid{
    display:grid;
    grid-template-columns: 190px 1fr 220px;
    gap:14px;
    margin-top: 16px;
  }

  .card{
    border-radius: var(--radius);
    background: linear-gradient(180deg, rgba(11,19,36,.85), rgba(9,14,24,.72));
    border:1px solid rgba(58,215,255,.16);
    box-shadow: var(--shadow);
    position:relative;
    overflow:hidden;
  }
  .card:before{
    content:"";
    position:absolute; inset:-2px;
    background: radial-gradient(700px 220px at 30% 0%, rgba(58,215,255,.12), transparent 60%);
    pointer-events:none;
  }
  .card h2{
    margin:0;
    padding: 12px 14px 8px;
    font-size:12px;
    letter-spacing:1.2px;
    text-transform:uppercase;
    color: rgba(215,231,255,.92);
  }
  .card .body{ padding: 10px 14px 14px; position:relative; }

  .btn{
    width:100%;
    display:flex; align-items:center; justify-content:flex-start;
    gap:10px;
    padding: 12px 12px;
    border-radius: 14px;
    border:1px solid rgba(58,215,255,.18);
    background: rgba(6,10,18,.55);
    color: var(--text);
    cursor:pointer;
    user-select:none;
    box-shadow: 0 12px 26px rgba(0,0,0,.3);
    transition: transform .08s ease, border-color .15s ease, background .15s ease;
    font-weight:650;
    letter-spacing:.2px;
  }
  .btn:active{ transform: scale(.99); }
  .btn:hover{ border-color: rgba(58,215,255,.30); background: rgba(8,14,26,.62); }
  .btn .ic{
    width:34px; height:34px; border-radius: 12px;
    display:grid; place-items:center;
    background: rgba(58,215,255,.10);
    border:1px solid rgba(58,215,255,.18);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .btn.secondary .ic{ background: rgba(75,255,138,.09); border-color: rgba(75,255,138,.18); }
  .btn.warn .ic{ background: rgba(255,207,91,.09); border-color: rgba(255,207,91,.18); }
  .btn.bad .ic{ background: rgba(255,75,92,.10); border-color: rgba(255,75,92,.18); }

  .btnrow{ display:flex; flex-direction:column; gap:10px; }

  /* Fabric ring */
  .fabric{
    display:grid;
    place-items:center;
    padding: 6px 6px 10px;
  }
  .ring{
    width:min(520px, 92vw);
    aspect-ratio: 1 / 1;
    max-height: 520px;
    display:grid;
    place-items:center;
    position:relative;
  }
  .ring:before{
    content:"";
    position:absolute; inset: 10%;
    border-radius: 999px;
    border:1px dashed rgba(58,215,255,.18);
    opacity:.7;
  }
  .node{
    position:absolute;
    width:62px; height:62px;
    border-radius: 999px;
    display:grid; place-items:center;
    font-weight:800;
    letter-spacing:.5px;
    border:1px solid rgba(255,255,255,.08);
    box-shadow:
      0 0 0 1px rgba(0,0,0,.35) inset,
      0 18px 35px rgba(0,0,0,.45);
    transform: translate(-50%, -50%);
  }
  .node.good{
    background: radial-gradient(circle at 30% 30%, rgba(75,255,138,.65), rgba(75,255,138,.18) 60%, rgba(10,18,32,.95) 100%);
    box-shadow: 0 0 22px rgba(75,255,138,.22), 0 18px 35px rgba(0,0,0,.45);
  }
  .node.bad{
    background: radial-gradient(circle at 30% 30%, rgba(255,75,92,.7), rgba(255,75,92,.18) 60%, rgba(10,18,32,.95) 100%);
    box-shadow: 0 0 22px rgba(255,75,92,.18), 0 18px 35px rgba(0,0,0,.45);
  }

  /* Telemetry */
  .kv{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:8px 10px;
    font-size:13px;
    margin-top: 2px;
  }
  .kv .k{ color: var(--muted); }
  .kv .v{ font-variant-numeric: tabular-nums; font-weight:700; }
  .kv .v.good{ color: var(--accent2); }
  .kv .v.bad{ color: var(--bad); }
  .kv .v.cyan{ color: var(--accent); }

  /* Timeline */
  .timelineWrap{
    grid-column: 1 / -1;
    display:grid;
    grid-template-columns: 1fr;
    gap:14px;
  }
  .timeline{
    padding-bottom: 12px;
  }
  canvas{
    width:100%;
    height: 210px;
    display:block;
    border-radius: 14px;
    background: rgba(3,6,12,.35);
    border:1px solid rgba(58,215,255,.12);
  }

  .footer{
    margin-top: 10px;
    color: rgba(143,177,217,.8);
    font-size: 11px;
    letter-spacing:.2px;
    opacity:.85;
    text-align:left;
    padding: 0 6px;
  }

  /* Mobile stacking */
  @media (max-width: 840px){
    .grid{ grid-template-columns: 1fr; }
    .meta{ min-width: auto; text-align:left; }
    .pill{ margin-left:0; }
    .ring{ width:min(520px, 96vw); }
  }

  /* Reduce motion */
  @media (prefers-reduced-motion: reduce){
    .btn{ transition:none; }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo">Î”</div>
      <div>
        <h1><span>DODECAPATCH</span> vSim-PRO v3 ULTRA</h1>
        <div class="sub">modular QC â€¢ leakage propagation â€¢ sticky quarantine â€¢ reroute pressure â€¢ timeline telemetry</div>
      </div>
    </div>

    <div class="meta">
      <div class="pill"><span class="dot"></span><span><b>MISSION:</b> Stability Test â€¢ <b>MODE:</b> Real-Time</span></div>
      <div><b>Offline</b> â€¢ No dependencies â€¢ Touch-first</div>
    </div>
  </header>

  <section class="grid">
    <div class="card">
      <h2>Control</h2>
      <div class="body">
        <div class="btnrow">
          <button class="btn" id="btnRun">
            <span class="ic">â–¶ï¸Ž</span><span id="runLabel">RUN</span>
          </button>
          <button class="btn warn" id="btnLeak">
            <span class="ic">ðŸ’¥</span><span>INJECT LEAK</span>
          </button>
          <button class="btn secondary" id="btnScrub">
            <span class="ic">ðŸ§¼</span><span id="scrubLabel">TOGGLE SCRUB</span>
          </button>
          <button class="btn bad" id="btnReset">
            <span class="ic">âŸ²</span><span>RESET</span>
          </button>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Fabric</h2>
      <div class="body fabric">
        <div class="ring" id="ring"></div>
      </div>
    </div>

    <div class="card">
      <h2>Telemetry</h2>
      <div class="body">
        <div class="kv">
          <div class="k">Cycle</div><div class="v cyan" id="tCycle">0</div>
          <div class="k">Quarantined</div><div class="v" id="tQ">0/12</div>
          <div class="k">Capacity</div><div class="v" id="tCap">100%</div>
          <div class="k">Avg Leakage</div><div class="v" id="tLeak">0.00</div>
          <div class="k">Scrub</div><div class="v" id="tScrub">OFF</div>
        </div>
      </div>
    </div>

    <div class="timelineWrap">
      <div class="card timeline">
        <h2>Leak hit timeline</h2>
        <div class="body">
          <canvas id="timeline" width="900" height="210"></canvas>
        </div>
      </div>
      <div class="footer">DodecaPatch Architecture â€¢ Offline â€¢ No Dependencies â€¢ Life-First</div>
    </div>
  </section>
</div>

<script>
(() => {
  // === Sim params (tweakable) ===
  const N = 12;
  const baseLeakP = 0.035;     // baseline leak chance per face per tick
  const scrubLeakP = 0.012;    // when scrub ON, lower chance
  const spreadP = 0.35;        // chance leak spreads to neighbor if a face is leaking
  const quarantineStick = 0.92;// probability quarantined stays quarantined when scrubbing
  const rerouteBoost = 0.06;   // extra leak chance when capacity is low (pressure)

  // === State ===
  let running = false;
  let scrub = false;
  let cycle = 0;

  // per face: ok(true/false), quarantined(true/false), leakLevel(0..)
  const faces = Array.from({length:N}, () => ({ ok:true, q:false, leak:0 }));

  // timeline: store last M points
  const M = 160;
  const hist = [];
  let histMax = 1;

  // === DOM ===
  const ring = document.getElementById("ring");
  const btnRun = document.getElementById("btnRun");
  const btnLeak = document.getElementById("btnLeak");
  const btnScrub = document.getElementById("btnScrub");
  const btnReset = document.getElementById("btnReset");
  const runLabel = document.getElementById("runLabel");
  const scrubLabel = document.getElementById("scrubLabel");
  const tCycle = document.getElementById("tCycle");
  const tQ = document.getElementById("tQ");
  const tCap = document.getElementById("tCap");
  const tLeak = document.getElementById("tLeak");
  const tScrub = document.getElementById("tScrub");

  const canvas = document.getElementById("timeline");
  const ctx = canvas.getContext("2d");

  // === Build ring nodes ===
  const nodes = [];
  for(let i=0;i<N;i++){
    const d = document.createElement("div");
    d.className = "node good";
    d.textContent = i;
    ring.appendChild(d);
    nodes.push(d);
  }

  function layoutRing(){
    const box = ring.getBoundingClientRect();
    const cx = box.width/2, cy = box.height/2;
    const R = Math.min(cx, cy) * 0.36;
    for(let i=0;i<N;i++){
      const a = (Math.PI*2*i/N) - Math.PI/2;
      const x = cx + R*Math.cos(a);
      const y = cy + R*Math.sin(a);
      nodes[i].style.left = x + "px";
      nodes[i].style.top  = y + "px";
    }
  }

  // === Metrics ===
  function countQuarantined(){
    let q=0;
    for(const f of faces) if(f.q) q++;
    return q;
  }
  function capacityPct(){
    // capacity is "healthy fraction" of faces not quarantined
    return Math.round(100 * (1 - countQuarantined()/N));
  }
  function avgLeak(){
    let s=0;
    for(const f of faces) s += f.leak;
    return s/N;
  }

  // === Timeline drawing ===
  function drawTimeline(){
    const w = canvas.width, h = canvas.height;
    // clear
    ctx.clearRect(0,0,w,h);

    // background subtle grid
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(58,215,255,0.12)";
    ctx.lineWidth = 1;

    const gx = 60, gy = 42;
    for(let x=0; x<=w; x+=gx){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0; y<=h; y+=gy){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }

    // axes
    ctx.strokeStyle = "rgba(215,231,255,0.20)";
    ctx.beginPath(); ctx.moveTo(36, 12); ctx.lineTo(36, h-24); ctx.lineTo(w-12, h-24); ctx.stroke();

    // label
    ctx.fillStyle = "rgba(143,177,217,0.85)";
    ctx.font = "12px system-ui";
    ctx.fillText("Leak hits (scaled)", 44, 24);

    // series
    if(hist.length < 2) return;

    const padL = 36, padR = 12, padT = 34, padB = 24;
    const W = w - padL - padR;
    const H = h - padT - padB;

    const maxV = Math.max(1, histMax);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(58,215,255,0.95)";
    ctx.shadowColor = "rgba(58,215,255,0.35)";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    for(let i=0;i<hist.length;i++){
      const x = padL + (W * i/(M-1));
      const v = hist[i];
      const y = padT + (H * (1 - (v/maxV)));
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // reset shadow
    ctx.shadowBlur = 0;

    // current marker
    const last = hist[hist.length-1];
    const x = padL + (W * (hist.length-1)/(M-1));
    const y = padT + (H * (1 - (last/maxV)));
    ctx.fillStyle = "rgba(75,255,138,0.95)";
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
  }

  function pushHist(v){
    hist.push(v);
    if(hist.length > M) hist.shift();
    // keep a lazy max for scaling
    histMax = Math.max(histMax*0.98, ...hist, 1);
    drawTimeline();
  }

  // === Render ===
  function render(){
    // nodes
    for(let i=0;i<N;i++){
      const f = faces[i];
      const isBad = f.q || f.leak > 0.2;
      nodes[i].className = "node " + (isBad ? "bad" : "good");
    }

    const q = countQuarantined();
    const cap = capacityPct();
    const av = avgLeak();

    tCycle.textContent = cycle;
    tQ.textContent = `${q}/${N}`;
    tCap.textContent = `${cap}%`;
    tLeak.textContent = av.toFixed(2);
    tScrub.textContent = scrub ? "ON" : "OFF";

    // colorize
    tQ.className = "v " + (q > N*0.5 ? "bad" : q > 0 ? "cyan" : "good");
    tCap.className = "v " + (cap < 40 ? "bad" : cap < 70 ? "cyan" : "good");
    tLeak.className = "v " + (av > 1.0 ? "bad" : av > 0.4 ? "cyan" : "good");
  }

  // === Simulation tick ===
  function tick(){
    cycle++;

    const q = countQuarantined();
    const cap = 1 - q/N;
    const pressure = (1 - cap); // higher when many quarantined
    const p0 = (scrub ? scrubLeakP : baseLeakP) + rerouteBoost * pressure;

    // leak spread + decay
    let leakHits = 0;

    // 1) baseline leaks + pressure
    for(let i=0;i<N;i++){
      const f = faces[i];
      if(f.q) continue;

      if(Math.random() < p0){
        f.leak += 0.7 + Math.random()*0.6;
        leakHits++;
      }
    }

    // 2) spread to neighbors
    for(let i=0;i<N;i++){
      const f = faces[i];
      if(f.q) continue;
      if(f.leak > 0.6 && Math.random() < spreadP){
        const j = (Math.random()<0.5) ? (i+1)%N : (i-1+N)%N;
        if(!faces[j].q){
          faces[j].leak += 0.4 + Math.random()*0.5;
          leakHits++;
        }
      }
    }

    // 3) quarantine rule: if leak too high -> quarantine
    for(let i=0;i<N;i++){
      const f = faces[i];
      if(!f.q && f.leak > 1.0){
        f.q = true;
      }
    }

    // 4) scrubbing: reduce leak and sometimes release quarantine
    for(let i=0;i<N;i++){
      const f = faces[i];
      if(scrub){
        f.leak *= 0.70; // scrub decay
        if(f.q){
          // sticky quarantine: usually stays, sometimes releases
          if(Math.random() > quarantineStick && f.leak < 0.35){
            f.q = false;
          }
        }
      } else {
        // natural slow decay
        f.leak *= 0.92;
      }
      if(f.leak < 0.02) f.leak = 0;
    }

    // timeline value: leakHits + a bit of avg leakage (so it doesn't go dead)
    const v = leakHits + avgLeak()*0.35;
    pushHist(v);

    render();
  }

  // === Actions ===
  function injectLeak(){
    // pick 1-3 random faces and spike leak
    const k = 1 + Math.floor(Math.random()*3);
    for(let n=0;n<k;n++){
      const i = Math.floor(Math.random()*N);
      if(!faces[i].q){
        faces[i].leak += 1.2 + Math.random()*1.2;
      }
    }
    render();
  }

  function resetAll(){
    running = false;
    scrub = false;
    cycle = 0;
    for(const f of faces){ f.ok=true; f.q=false; f.leak=0; }
    hist.length = 0; histMax = 1;
    runLabel.textContent = "RUN";
    scrubLabel.textContent = "TOGGLE SCRUB";
    pushHist(0);
    render();
  }

  // === Wire ===
  btnRun.addEventListener("click", () => {
    running = !running;
    runLabel.textContent = running ? "PAUSE" : "RUN";
  });

  btnLeak.addEventListener("click", injectLeak);
  btnScrub.addEventListener("click", () => { scrub = !scrub; render(); });
  btnReset.addEventListener("click", resetAll);

  // === Main loop ===
  let last = 0;
  function loop(ts){
    if(!last) last = ts;
    const dt = ts - last;
    last = ts;

    // ~12.5fps tick cap to keep phone happy
    if(running){
      // accumulate ticks roughly every 80ms
      loop.acc = (loop.acc||0) + dt;
      while(loop.acc >= 80){
        loop.acc -= 80;
        tick();
      }
    }
    requestAnimationFrame(loop);
  }

  // Resize canvas to container
  function fitCanvas(){
    const box = canvas.parentElement.getBoundingClientRect();
    const w = Math.max(520, Math.floor(box.width));
    if(canvas.width !== w){
      canvas.width = w;
      canvas.height = 210;
      drawTimeline();
    }
  }

  window.addEventListener("resize", () => { layoutRing(); fitCanvas(); }, {passive:true});

  layoutRing();
  fitCanvas();
  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
